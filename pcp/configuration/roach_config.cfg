# Configuration file for roach hardware options (e.g. dds_shifts, fft_bin size, accum, firmware registers)

MAXCHANNELS: 1012

totallen: 8234
headerstart: 0
headerlen: 42
datalen: 8192
datatype: signed long

timingtype: unsigned long
timingendian: big

# attempt to write down the packet format, just in case it changes
PACKETSTRUCT: # all numbers in bytes
  header_len: 42
  ntones: 986
  header_list: {}
  kid_field_cfg:
    entry_type:     _gd.RAW_ENTRY
    field_datatype: _gd.FLOAT64
    datatype:       "<i4"
  aux_field_cfg: {
                "raw_packet"       :[_gd.STRING_ENTRY, _gd.NULL,   0,    0,  1, null], # save raw packets as strings (requires no type parameter)
                "python_timestamp" :[_gd.RAW_ENTRY,    _gd.UINT32, 0,    0,  1, ">u4"], # rough python timestamp in seconds after epoch (see kidpy )
                "pps_timestamp"    :[_gd.RAW_ENTRY,    _gd.UINT32, -17, -13, 1, ">u4"], # seconds elapsed since 'pps_start'
                "fine_timestamp"   :[_gd.RAW_ENTRY,    _gd.UINT32, -13, -9,  1, ">u4"], # milliseconds since PPS
                "packet_count"     :[_gd.RAW_ENTRY,    _gd.UINT32, -9,  -5,  1, ">u4"], # packet count since 'pps_start'
                "packet_info_reg"  :[_gd.RAW_ENTRY,    _gd.UINT32, -5,  -1,  1, ">u4"],  # 32-bit int written to the info_register
                "roach_checksum"   :[_gd.RAW_ENTRY,    _gd.UINT32, -21, -17, 1, ">u4"],
                "gpio_reg"         :[_gd.RAW_ENTRY,    _gd.UINT8,  -1, null, 1, ">u1"] # hardware controlled 8-bit gpio pins
              }
    # roach_checksum = (np.fromstring(rawpacket[-21:-17],dtype = '>I'))
    # # seconds elapsed since 'pps_start'
    # sec_ts = (np.fromstring(rawpacket[-17:-13],dtype = '>I'))
    # # milliseconds since PPS
    # fine_ts = np.round((np.fromstring(rawpacket[-13:-9],dtype = '>I').astype('float')/256.0e6)*1.0e3,3)
    # # raw packet count since 'pps_start'
    # packet_count = (np.fromstring(rawpacket[-9:-5],dtype = '>I'))
    # packet_info_reg = (np.fromstring(rawpacket[-5:-1],dtype = '>I'))
    # gpio_reg = (np.fromstring(rawpacket[-1:],dtype = np.uint8))

roach1:
  synthid: synth1
  synth_step: 1.0e3
  center_freq: 828.0   # LO center frequency, MHz
  Nfreq: 1000   # Number of frequencies in test com
  max_pos_freq: 246.001234e6   # Maximum positive frequency, Hz
  min_pos_freq: 1.02342e6 # Minimum positive frequency, Hz
  max_neg_freq: -1.02342e6   # Maximum negative frequency, Hz
  min_neg_freq: -246.001234e6   # Minimum negative frequency, Hz
  symm_offset: 250.0e3 # Offset between positive and negative combs, Hz

roach2:
  synthid: synth1
  synth_step: 1.0e3
  center_freq: 828.0   # LO center frequency, MHz
  Nfreq: 1000   # Number of frequencies in test com
  max_pos_freq: 246.001234e6   # Maximum positive frequency, Hz
  min_pos_freq: 1.02342e6 # Minimum positive frequency, Hz
  max_neg_freq: -1.02342e6   # Maximum negative frequency, Hz
  min_neg_freq: -246.001234e6   # Minimum negative frequency, Hz
  symm_offset: 250.0e3 # Offset between positive and negative combs, Hz

 #   69  * UDP packet structure:
 # 70  * -----------------------
 # 71  * Total length: 8234 bytes
 # 72  * Header: 42 bytes
 # 73  * Data + timing info: 8192 bytes
 # 74  * Data type: 32b signed integers
 # 75  *     - Data should be unpacked as little-endian
 # 76  * Number of channels: 1024
 # 77  *     - Each channel has a 32b I value, and a 32b Q value
 # 78  * Values:
 # 79  * 1 - 512: Channels 0 - 512, I values
 # 80  * 513 - 1024: Channels 0 - 512, Q values
 # 81  * 1025 - 1536: Channels 513 - 1024, I values
 # 82  * 1537 - 2048: Channels 513 - 1024, Q values
 # 83
 # "..the indices refer to 4 byte slots. So, the first block of 512 4 byte slots contain the I values for the
 # even channels (0, 2, 4, ...1022 ), and the second block of 512 contains the Q values. The next two blocks contain the I and Q
 # for the odd channels. (1,3,5,...1023) " -> this makes 1024 channels -> 1024*4 bytes * 2 (i and q) = 8192 bytes
 # 84  * Note: There are technically 1024 data channels,
 # 85  * but the last 20 bytes of the packet
 # 86  * are used to store timing information, limiting the number
 # 87  * of useable channels to 1012
 # 88  *
 # 89  * The information stored in the last 20 bytes:
 # 90  *     - Should be unpacked as BIG-endian, unsigned
 # 91  *     - Consists of five 32b unsigned ints
 # 92  *     - From end of packet, these are:
 #       * Packet info /* 32b register for arbitrary info to be saved into udp packet before transmission. */
 # 93  * Raw packet count /* Initialized to 0 with 'GbE_pps_start' */
 # 94  * Fine timestamp /* Clock cycles elapsed since last PPS pulse */
 # 95  * Course timestamp /* The number of PPS pulses elapsed since 'pps_start' */
 # 96  * Data checksum /* Currently a constant placeholder, 42 (in progress) */
 # 97  *
 # 98  **********************************************************************
